@startuml シーケンス図

Actor "ユーザー" as User

User -> main: ナップサックの容量、アイテムの個数の入力
main -> Knapsack: ナップサックの容量の入力
main <-- Knapsack: 成功したかどうかの判定
main -> Item_list: アイテムの個数分のアイテムリストの作成
main <-- Item_list: 成功したかどうかの判定
main <- Item_list: 登録済みのアイテムリストの上限（アイテムの個数と同じ数値）を取得

loop 入力されたアイテムの個数の数までループ
    User -> main: ユーザーのアイテムデータ（価値,重さ）登録
    main -> Item:アイテムクラスの作成
    main <-- Item:アイテムクラスの取得
    main -> Item: アイテムに価値の登録
    main <-- Item: 成功したかどうかの判定
    main -> Item: アイテムに重さの登録
    main <-- Item: 成功したかどうかの判定
    main <- Item: 登録済みのアイテム情報を取得
    main -> Item_list: アイテム情報をリストに登録
    main <-- Item_list:　成功したかどうかの判定
end
main -> Sum: dp_max()呼び出し
Sum -> Item_list: アイテムリストの呼び出し
Sum <-- Item_list:アイテムリストの取得 
Sum -> Item_list: アイテムリストの上限（アイテムの個数）の取得
Sum <-- Item_list: 成功したかどうかの判定
Sum -> Knapsack:ナップサックの容量呼び出し
Knapsack --> Sum: 成功したかどうかの判定

Sum -> Sum: dpテーブル作成

loop アイテムの個数まで回す(i)
    loop ナップサックの容量まで回す(j)
        alt jのループがItem_list[i]番目の重さ以上の場合            
            alt 今回のデータ((dp[i][j-Item_list[i].weight) + Item_list[i].value)が前回のItem_list[i][j]のデータよりも多い場合
                Sum -> Sum:次のdp[i + 1][j]に今回のデータを入れる
            else 今回のデータが前回のデータ以下場合
                Sum -> Sum:次のdpテーブルに前回のデータを入れる
            end
        else jのループがitem_list[i]番目の価値よりもしたの場合
            Sum -> Sum:次のdpテーブルに前回のデータを入れる
        end
    end
end

Sum -> Sum: 最大値(max_sum)まで回す関数（maxSum_update）を呼ぶ。

loop ナップサックの容量まで回す(i)
    alt dpテーブル[item_list_len]行の中の価値が前回までの最大値(max_sum)よりも多い場合
        Sum -> Sum: maxSumの値を更新
    end
end

main <-- Sum: 最大値取得
main -> User: 結果出力

@enduml