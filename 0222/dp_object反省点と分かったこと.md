# 反省点
1. 変数が分かりにくい（item *itemなど）
1. item_listの変数の取り出しの時などにエラーが出る時の対策
1. 配列をリストにする→入力されるアイテムの個数を保持する場所がなくなる→リストに現在のlenを見ることができない。
1. 初期値をきちんと記入していない0の場合もあれば、Nの場合もあるからきちんと記入する
1. シーケンス図の遷移を細かく書いていなかった。（アイテム作成とだけあって実際の処理は価値と重さの登録と2回分の処理があった。）
1. 静的なものはクラス図、動的なものがシーケンス図と区別できなかった。 
1. ループの回数などをしっかりと考えていなかった。
1. インポート文は書くたびに初期化をされるので、main()の中で書いたらそのデータごと渡さないといけない。
1. インスタンスするタイミングをきちんと明記しなければならない。
1. for文の書き方が未満や以下などの表記でないとコーティング時にどうすればいいか分からなくなる。
1. 日本語でシーケンス図を書くとプログラムで書く際にどう処理するのか分からない。
1. 処理を一行に2つ書いてある。
1. シーケンス図はimportをしている時を表しているので、とりあえず全部上に書いておくのではいけない。
1. 変数sumが分かりにくい
1. シーケンス図は一筆書きでなければならない。
1. ユーザーはプログラムの実行から始まる。
1. シーケンスの返り値の変数を書かないといけない  
1. 個数の入力制限などをどこで確認するか決めなくてはならない。
1. シーケンス図には関数の他に変数も書かないと分からない。

# 分かったこと

## リストでの領域確保する場合の書き方
1. リストでの領域確保する場合の書き方は  
```
list = [0 for i < range(100)]
```  
で[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0・・・]のようなリストを作ることができる。

1. list = [[0]*100000]*100  
この書き方だと0番目の配列のコピーとなるので、独立した配列にならない。要は2次元配列ではない

## 2次元配列の作り方
2次元配列宣言のやり方の1つとして
```
list =  [[0 for i < range(100)]*100]
```
と配列をいくつ作るかのように宣言すると2次元配列のリスト型になる。


## 初期値について
初期値にもいろいろと種類がある(NULLや0など)、それはきちんと詳細設計で明示しなければならない。
また初期値を記入してもPythonだと後から型ごと変更できるので注意が必要。

## シーケンス図とクラス図の分類
クラス図は基本的に静的モデル  
シーケンス図は動的モデルと書かれている。  

クラス図はそもそも静的構造で必要なものを列挙していくものであり、  
動的挙動の部分はシーケンス図が担っている。

## クラスのカプセル化のクラス設計者の責任問題
モジュール毎に設定することで、今どのプログラムが問題あるかと部分分けすることができる。  
最低限の動きが保証されているならクラス図の設計者の責任にならない。

## selfの使い方  
　selfは基本的に自分のクラスを見るちう意味。  
  関数宣言ではmath(self)のように必ず書かなければならない。

  自分のクラスの関数を呼ぶ場合、self.math()で使う。  
  この場合は、引数に（self）と書かなくてよい

## クラス図に書き起こすもの
基本的に静的（他の場所で使うもの）は書く。  
一時的なものや動的に変わるものは書かなくてもいい。  
バグを生まないようにするにはプログラムを書かなければいい →　クラス図やシーケンス図は必要最低限でよい。  
（色々と書くと不必要な動きが生まれてバグになる）  

## シーケンス図  
一本線（->）は出す側  
二本線（-->）は取得側  
シーケンス