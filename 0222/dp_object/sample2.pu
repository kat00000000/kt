@startuml シーケンス図

Actor "ユーザー" as User
User -> main: プログラム起動
User -> main:アイテムの個数の入力
User -> main:ナップサックの容量の個数の入力

main -> Knapsack:ナップサックの容量の個数の入力
main <-- Knapsack: 成功したかどうかの判定

main -> Item_list: アイテムの個数分のアイテムリストの作成
main <-- Item_list: 成功したかどうかの判定
main -> Item_list: 登録済みのアイテムリストの上限（アイテムの個数と同じ数値）の呼び出し
main <-- Item_list: 登録済みのアイテムリストの上限（アイテムの個数と同じ数値）を取得

loop 入力されたアイテムの個数の数までループ
    User -> main: ユーザーからアイテムデータ（価値）登録
    User -> main:ユーザーからアイテムデータ（重さ）登録
    main -> Item:アイテムクラスの作成
    main <-- Item:アイテムクラスの取得
    main -> Item: アイテムに価値の登録
    main <-- Item: 成功したかどうかの判定
    main -> Item: アイテムに重さの登録
    main <-- Item: 成功したかどうかの判定
    main -> Item_list: アイテム情報をリストに登録
    main <-- Item_list:　成功したかどうかの判定
end
main -> Dp: dp_max()呼び出し
Dp -> Item_list: アイテムリストの呼び出し
Dp <-- Item_list:アイテムリストの取得 
Dp -> Item_list: アイテムリストの上限（アイテムの個数）の呼び出し
Dp <-- Item_list: アイテムリストの上限の取得
Dp -> Knapsack:ナップサックの容量呼び出し
Knapsack --> Dp: ナップサック容量の取得

Dp -> Dp: dpテーブル作成

loop アイテムの個数未満まで回す(i)
    loop ナップサックの容量以下まで回す(j)
        alt jのループがItem_list[i]番目の重さ以上の場合            
            alt 今回のデータ((dp[i][j-Item_list[i].weight) + Item_list[i].value)が前回のItem_list[i][j]のデータよりも多い場合
                Dp -> Dp:次のdp[i + 1][j]に今回のデータを入れる
            else 今回のデータが前回のデータ以下場合
                Dp -> Dp:次のdpテーブルに前回のデータを入れる
            end
        else jのループがitem_list[i]番目の価値よりもしたの場合
            Dp -> Dp:次のdpテーブルに前回のデータを入れる
        end
    end
end

Dp -> Dp: 最大値(max_sum)まで回す関数（maxSum_update）を呼ぶ。

loop ナップサックの容量未満まで回す(i)
    alt dpテーブル[item_list_len]行の中の価値が前回までの最大値(max_sum)よりも多い場合
        Dp -> Dp: maxSumの値を更新
    end
end

main <-- Dp: 最大値取得
main -> User: 最大値の出力

@enduml